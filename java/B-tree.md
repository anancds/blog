# B-Tree 和 B+ tree

关于2-3 tree和红黑树可以参考[algs4](http://algs4.cs.princeton.edu/lectures/33BalancedSearchTrees.pdf)

## 应用场景

B树设计的原因就是降低在实际操作中对硬盘的访问。

首先，海量数据需要存储在硬盘上，而访问硬盘的速度是非常慢的，所以需要减少访问硬盘的次数。这里举例说明：因为B树的每个节点可以存多个元素，假设每个节点可以存1000个元素，那么如果B树有三层，这棵B树就可以存10亿元素，我们只需要将根节点存放在内存中，在查找某个数据时，只需要两次硬盘访问就可以查找到数据，极大的降低了硬盘的访问次数。

B/B+ tree通过对每个节点存储个数的扩展，使得对连续的数据进行较快的定位和访问，能够有效减少查找时间，提高存储空间局部性从而减少IO操作，广泛应用于文件系统和数据库。

## B-tree定义
B树可以看作是对2-3 tree查找树的一种扩展，即允许每个节点有M-1个子节点。

* 根节点至少有两个子节点
* 每个节点有M-1个key，并且以升序排列
* 位于M-1和M key的子节点的值位于M-1和M key对应的value之间
* 其它节点至少有M/2个子节点

## 例子
在一个10阶的B-树上，每个树根结点中所含的关键字数目最多允许为( )个，最少允许为( )个。
答案是：最多9个，最少4个。
如果想套用公式的话，那么就是[ceil(m / 2)-1]<= n <= m-1  （ceil为取上整）
其实如果知道插入的流程完成没必要记公式，接下来就是插入流程。

## b-tree 插入流程
可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。
B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入
6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4
的演示动画：
![](http://files.cnblogs.com/yangecnu/btreebuild.gif)

## B+ tree定义

B+ tree是B-tree的一种变形树，它与B-tree的区别是：

* 有K个子节点的节点必然有K个关键码
* 非叶子节点仅具有索引作用，跟记录有关的信息均存放在叶子节点
* 树的所有叶子节点构成一个有序链表，可以按照关键码排序的次序遍历全部记录

## B+ tree插入流程

![](http://files.cnblogs.com/yangecnu/Bplustreebuild.gif)

## B-tree和B+ tree的区别

B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

B+ 树的优点在于：
* 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。
* B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：
![](http://images.cnitblog.com/blog/94031/201403/290050088914733.png)

## 参考
* [http://blog.csdn.net/v_july_v/article/details/6530142](http://blog.csdn.net/v_july_v/article/details/6530142)
